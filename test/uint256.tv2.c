#include <stdio.h>
#include <assert.h>
#include <uint256.h>


#define MAX_U64 0xffffffffffffffffULL

void print_uint(const char *label, u256 x) {
    printf("%s[0]: %lu\n%s[1]: %lu\n%s[2]: %lu\n%s[3]: %lu\n",
           label, x[0], label, x[1], label, x[2], label, x[3]);
}

void assert_eq(u256 have, u256 want) {
    assert(have[0] == want[0]);
    assert(have[1] == want[1]);
    assert(have[2] == want[2]);
    assert(have[3] == want[3]);
}

void verbose_assert_eq(u256 have, u256 want, char name[], char msg[]) {
    if ((have[0] != want[0]) || (have[1] != want[1])
     || (have[2] != want[2]) || (have[3] != want[3]))
    {
        printf("%s failed: %s\n", name, msg);
        print_uint("want", want);
        print_uint("have", have);
        assert_eq(have, want);
    }
}

void test_add_overflows() {
    u256 x = {MAX_U64, MAX_U64, MAX_U64, MAX_U64};
    u256 y = {1, 0, 0, 0};
    u256 want = {0, 0, 0, 0};

    u256 have;
    add(have, x, y);

    verbose_assert_eq(have, want, "Add", "Should overflow correctly");
}

void test_and() {
    u256 x = {
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111
    };
    u256 y = {
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111
    };
    u256 want = {
        0b1110000000000000000001111111000000000000000000000000000000000111,
        0b1110000000000000000001111111000000000000000000000000000000000111,
        0b1110000000000000000001111111000000000000000000000000000000000111,
        0b1110000000000000000001111111000000000000000000000000000000000111
    };

    u256 have;
    and(have, x, y);

    verbose_assert_eq(have, want, "And", "Should succeed");
}

void test_or() {
    u256 x = {
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111
    };
    u256 y = {
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111
    };
    u256 want = {
        0b1111111111111111111111111111111111111111111111111111111111111111,
        0b1111111111111111111111111111111111111111111111111111111111111111,
        0b1111111111111111111111111111111111111111111111111111111111111111,
        0b1111111111111111111111111111111111111111111111111111111111111111
    };

    u256 have;
    or(have, x, y);

    verbose_assert_eq(have, want, "Or", "Should succeed");
}

void test_xor() {
    u256 x = {
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111
    };
    u256 y = {
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111,
        0b1110000000000000000001111111111111111111111111111111111111111111
    };
    u256 want = {
        0b0001111111111111111110000000111111111111111111111111111111111000,
        0b0001111111111111111110000000111111111111111111111111111111111000,
        0b0001111111111111111110000000111111111111111111111111111111111000,
        0b0001111111111111111110000000111111111111111111111111111111111000
    };

    u256 have;
    xor(have, x, y);

    verbose_assert_eq(have, want, "Xor", "Should succeed");
}

void test_not() {
    u256 x = {
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111,
        0b1111111111111111111111111111000000000000000000000000000000000111
    };
    u256 want = {
        0b0000000000000000000000000000111111111111111111111111111111111000,
        0b0000000000000000000000000000111111111111111111111111111111111000,
        0b0000000000000000000000000000111111111111111111111111111111111000,
        0b0000000000000000000000000000111111111111111111111111111111111000
    };

    u256 have;
    not(have, x);

    verbose_assert_eq(have, want, "Not", "Should succeed");
}

void test_byte() {
    /*
        Check each index in this test. Note that `byte` indexes the byte as if
        the number was big-endian, even though we store them in little-endian
        order in the u256 type.
    */
    u256 x = {
        0x00000000000000ee,
        0x00000000000000dd,
        0x00000000000000cc,
        0x00000000000000bb
    };
    u256 i = {31, 0, 0, 0};
    u256 want = {
        0x00000000000000ee,
        0x0000000000000000,
        0x0000000000000000,
        0x0000000000000000
    };
    u256 have;
    byte(have, x, i);
    verbose_assert_eq(have, want, "Byte", "Should retrieve byte 31");

    char msg[32];

    for (int j = 0; j < 7; j++) {
        x[0] <<= 8;
        i[0] -= 1;
        byte(have, x, i);
        sprintf(msg, "Should retrieve byte %lu", i[0]);
        verbose_assert_eq(have, want, "Byte", msg);
    }

    want[0] = 0x00000000000000dd;
    i[0] -= 1;
    byte(have, x, i);
    verbose_assert_eq(have, want, "Byte", "Should retrieve byte 23");

    for (int j = 0; j < 7; j++) {
        x[1] <<= 8;
        i[0] -= 1;
        byte(have, x, i);
        sprintf(msg, "Should retrieve byte %lu", i[0]);
        verbose_assert_eq(have, want, "Byte", msg);
    }

    want[0] = 0x00000000000000cc;
    i[0] -= 1;
    byte(have, x, i);
    verbose_assert_eq(have, want, "Byte", "Should retrieve byte 15");

    for (int j = 0; j < 7; j++) {
        x[2] <<= 8;
        i[0] -= 1;
        byte(have, x, i);
        sprintf(msg, "Should retrieve byte %lu", i[0]);
        verbose_assert_eq(have, want, "Byte", msg);
    }

    want[0] = 0x00000000000000bb;
    i[0] -= 1;
    byte(have, x, i);
    verbose_assert_eq(have, want, "Byte", "Should retrieve byte 7");

    for (int j = 0; j < 7; j++) {
        x[3] <<= 8;
        i[0] -= 1;
        byte(have, x, i);
        sprintf(msg, "Should retrieve byte %lu", i[0]);
        verbose_assert_eq(have, want, "Byte", msg);
    }

}

void test_shl() {
    u256 x = {
        0b1110000000000000000001111111000000000000000000000000000000000111,
        0b1110000000000000000001111111000000000000000000000000000000000111,
        0b1110000000000000000001111111000000000000000000000000000000000111,
        0b1110000000000000000001111111000000000000000000000000000000000111
    };
    u256 shift = {3, 0, 0, 0};
    u256 want = {
        0b0000000000000000001111111000000000000000000000000000000000111000,
        0b0000000000000000001111111000000000000000000000000000000000111111,
        0b0000000000000000001111111000000000000000000000000000000000111111,
        0b0000000000000000001111111000000000000000000000000000000000111111
    };

    u256 have;
    shl(have, x, shift);

    verbose_assert_eq(have, want, "Shl", "Should succeed");
}

void test_shr() {
    u256 x = {
        0b1110001111111111111111111111111111111111111111111111111111000111,
        0b1110001111111111111111111111111111111111111111111111111111000111,
        0b1110001111111111111111111111111111111111111111111111111111000111,
        0b1110001111111111111111111111111111111111111111111111111111000111
    };
    u256 shift = {3, 0, 0, 0};
    u256 want = {
        0b1111110001111111111111111111111111111111111111111111111111111000,
        0b1111110001111111111111111111111111111111111111111111111111111000,
        0b1111110001111111111111111111111111111111111111111111111111111000,
        0b0001110001111111111111111111111111111111111111111111111111111000
    };

    u256 have;
    shr(have, x, shift);

    verbose_assert_eq(have, want, "Shr", "Should succeed");
}

void test_sar() {
    u256 x = {
        0b1110001111111111111111111111111111111111111111111111111111000111,
        0b1110001111111111111111111111111111111111111111111111111111000111,
        0b1110001111111111111111111111111111111111111111111111111111000111,
        0b1110001111111111111111111111111111111111111111111111111111000111
    };
    u256 shift = {3, 0, 0, 0};
    u256 want = {
        0b1111110001111111111111111111111111111111111111111111111111111000,
        0b1111110001111111111111111111111111111111111111111111111111111000,
        0b1111110001111111111111111111111111111111111111111111111111111000,
        0b0001110001111111111111111111111111111111111111111111111111111000
    };

    u256 have;
    shr(have, x, shift);

    verbose_assert_eq(have, want, "Sar", "Should succeed");
}

int main() {
    //////////////////////////// Arithmetic tests
    test_add_overflows();
    // Mul
    // Sub
    // Div
    // SDiv
    // Mod
    // SMod
    // AddMod
    // MulMod
    // Exp
    // SignExtend

    //////////////////////////// Comparison tests
    // Lt
    // Gt
    // Slt
    // Sgt
    // Eq
    // IsZero

    //////////////////////////// Bitwise tests
    test_and();
    test_or();
    test_xor();
    test_not();
    test_byte();
    test_shl();
    test_shr();
    test_sar();
}
